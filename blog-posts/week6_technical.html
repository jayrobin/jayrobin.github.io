<!DOCTYPE html>
<html>
	<head>
		<title>Jayrobin @ DBC</title>
		<meta charset='utf-8'>
		<link rel="shortcut icon" href="../images/favicon.ico">
		<link rel='stylesheet' href='../blog-posts/stylesheets/reset.css'>
		<link rel='stylesheet' href='../blog-posts/stylesheets/blog.css'>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-2202293-16', 'jayrobin.github.io');
      ga('send', 'pageview');

    </script>
	</head>
	<body ontouchstart>
		<header>
			<h1>JAYROBIN</h1>
			<nav>
				<ul>
					<li id='home'><a href='../index.html'>Home</a></li>
					<li id='about'><a href='../about.html'>About</a></li>
					<li id='github'><a href='http://www.github.com/jayrobin'>GitHub</a></li>
					<li id='contact'><a href='mailto:james.michael.robinson@gmail.com'>Contact</a></li>
				</ul>
			</nav>
			<h2>Or: how I learned to stop worrying and love programming</h2>
		</header>
		<main>
			<section>
				<article>
					<h3>Week Six - Technical blog</h3>
					<span class="article_content">
						<p class='date'>08 Jul 2014</p>
						<h4>Blocks</h4>
						<p>Blocks are a distinct grouping of code in ruby, to be run or passed to another method. They can be written in either of the following ways:</p>
						<span class='code'>
							<span># curly braces should be used if the block is all on one line</span>
							<span>{ puts "Hello, world." }</span>
						</span>
						<span class='code'>
							<span># do...end should be used if the block spans multiple lines</span>
							<span>do</span>
							<span>&nbsp;&nbsp;puts "Hello, world."</span>
							<span>end</span>
						</span>
						<p>Blocks are called by passing them into a method that will temporarily give control to them using the 'yield' keyword:</p>
						<span class='code'>
							<span>def three_times</span>
							<span>&nbsp;&nbsp;yield</span>
							<span>&nbsp;&nbsp;yield</span>
							<span>&nbsp;&nbsp;yield</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span>three_times { puts "Hello, world." }</span>
							<span># => Hello, world.</span>
							<span># => Hello, world.</span>
							<span># => Hello, world.</span>
						</span>
						<p>The above code will call 'three_times' and pass the block. Within three_times, the block is yielded to three times in a row, running the code within the block three times and therefore printing out the message three times.</p>

						<h4>Procs</h4>
						<p>Procs are quite similar to blocks: they are a grouping of code that can be run later. Similar to blocks, they can be defined in two ways:</p>
						<span class='code'>
							<span>my_proc = Proc.new { puts "Hello, world." }</span>
						</span>
						<span class='code'>
							<span>my_proc = Proc.new do</span>
							<span>&nbsp;&nbsp;puts "Hello, world."</span>
							<span>end</span>
						</span>
						<p>As seen above, unlike blocks, Procs can be stored in variables - this allows them to be arbitrarily called without the need to be passed into a method and yielded to:</p>
						<span class='code'>
							<span>my_proc = Proc.new { puts "Hello, world." }</span>
							<span>&nbsp;</span>
							<span>my_proc.call</span>
							<span># => Hello, world.</span>
							<span>&nbsp;</span>
							<span>my_proc.call</span>
							<span># => Hello, world.</span>
						</span>
						<p>Since Procs are ruby objects, we can call other methods on them as well:</p>
						<span class='code'>
							<span>my_proc = Proc.new { puts "Hello, world." }</span>
							<span>&nbsp;</span>
							<span>my_proc.class</span>
							<span># => Proc</span>
							<span>&nbsp;</span>
							<span>my_proc.clone</span>
							<span># => #&lt;Proc:0x00000102930618@(irb):118&gt;</span>
						</span>
						<p>The other big difference and key benefit of Procs over blocks, is that we can easily pass multiple Procs to a method - something which is impossible with blocks:</p>
						<span class='code'>
							<span>def call_both(proc1, proc2)</span>
							<span>&nbsp;&nbsp;proc1.call</span>
							<span>&nbsp;&nbsp;puts "Inbetween"</span>
							<span>&nbsp;&nbsp;proc2.call</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span>proc1 = Proc.new { puts "First" }</span>
							<span>proc2 = Proc.new { puts "Second" }</span>
							<span>call_both(proc1, proc2)</span>
							<span># => First</span>
							<span># => Inbetween</span>
							<span># => Second</span>
						</span>

						<h4>Lambdas</h4>
						<p>Lambdas are a type of Proc in ruby and they are created in a similar manner:</p>
						<span class='code'>
							<span>my_lambda = lambda { puts "Hello, world." }</span>
						</span>
						<span class='code'>
							<span>my_lambda = lambda do</span>
							<span>&nbsp;&nbsp;puts "Hello, world."</span>
							<span>end</span>
						</span>
						<p>As of ruby 1.9, they can also be created with lambda literals (also known as stabby lambdas, which is a fantastic name):</p>
						<span class='code'>
							<span>my_lambda = -> { puts "Hello, world." }</span>
						</span>
						<span class='code'>
							<span>my_lambda = -> do</span>
							<span>&nbsp;&nbsp;puts "Hello, world."</span>
							<span>end</span>
						</span>
						<p>There are two key differences between Procs and lambdas: the first is that Procs do not care if the number of arguments passed in match the number of arguments expected, where as lambdas do:</p>
						<span class='code'>
							<span>my_proc = Proc.new do |name|</span>
							<span>&nbsp;puts "Hello, #{name}."</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span># Too few arguments results in 'nil' being used</span>
							<span>my_proc.call</span>
							<span># => Hello, nil.</span>
							<span>&nbsp;</span>
							<span># Too many arguments results in extras being discarded</span>
							<span>my_proc.call("John", "Smith")</span>
							<span># => Hello, John.</span>
						</span>
						<p>Compare the above code, converted into using lambdas:</p>
						<span class='code'>
							<span>my_lambda = lambda do |name|</span>
							<span>&nbsp;puts "Hello, #{name}."</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span># Too few arguments results in ArgumentError</span>
							<span>my_lambda.call</span>
							<span># => ArgumentError: wrong number of arguments</span>
							<span>&nbsp;</span>
							<span># Too many arguments results in ArgumentError</span>
							<span>my_lambda.call("John", "Smith")</span>
							<span># => ArgumentError: wrong number of arguments</span>
							<span>&nbsp;</span>
							<span># Correct number of arguments supplied</span>
							<span>my_lambda.call("John")</span>
							<span># => Hello John.</span>
						</span>
						<p>The above lambda could also be written in 1.9 syntax like so:</p>
						<span class='code'>
							<span>my_lambda = ->(name) { puts "Hello, #{name}." }</span>
						</span>
						<p>The final difference between Procs and lambdas is in how they handle 'return' statements. A lambda will just exit the block and return control to the container method, where as a Proc will return <em>out</em> of the container method entirely and back to where the method was originally called from:</p>
						<span class='code'>
							<span>def check_return(proc)</span>
							<span>&nbsp;&nbsp;puts "executing the method"</span>
							<span>&nbsp;&nbsp;puts proc.call</span>
							<span>&nbsp;&nbsp;puts "finishing the method"</span>
							<span>&nbsp;</span>
							<span>&nbsp;&nbsp;return "returned from the method"</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span>proc = Proc.new do</span>
							<span>&nbsp;&nbsp;puts "executing the proc</span>
							<span>&nbsp;&nbsp;return "returned from the Proc"</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span>puts check_return(proc)</span>
							<span># => executing the method</span>
							<span># => executing the proc</span>
							<span># => returned from the Proc</span>
						</span>
						<p>The code above will pass the proc to check_return, print the first message in the method, call the proc, print the first message in the proc, then return the second message from the proc back to the original method call to be printed.</p>
						<span class='code'>
							<span>def check_return(lambda)</span>
							<span>&nbsp;&nbsp;puts "executing the method"</span>
							<span>&nbsp;&nbsp;puts lambda.call</span>
							<span>&nbsp;&nbsp;puts "finishing the method"</span>
							<span>&nbsp;</span>
							<span>&nbsp;&nbsp;return "returned from the method"</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span>lambda = lambda do</span>
							<span>&nbsp;&nbsp;puts "executing the lambda</span>
							<span>&nbsp;&nbsp;return "returned from the lambda"</span>
							<span>end</span>
							<span>&nbsp;</span>
							<span>puts check_return(lambda)</span>
							<span># => executing the method</span>
							<span># => executing the lambda</span>
							<span># => returned from the lambda</span>
							<span># => finishing the method</span>
							<span># => returned from the method</span>
						</span>
						<p>The code above will pass the lambda to check_return, print the first message in the method, call the lambda, print the first message in the lambda, then return the second message from the lambda back to check_return, which will print it out, then print the second "finishing" message in the method, and finally return the last message in the method back to the original method call to be printed.</p>
						<p>So which is better - blocks, Procs or lambdas? The truth is, they each have their place: blocks are most appropriate when used as one-off applications with enumerators, while Procs and lambdas are far more useful when re-usability is required, or a method needs multiple code blocks to be passed (e.g. callbacks), and lambdas offer stricter parameter checking over Procs where necessary.</p>

						
				</article>
			</section>
		</main>
		<footer>
			<nav>
				<ul>
					<li>
						<a href='https://www.facebook.com/jamesmichaelrobinson'>
							<span aria-hidden="true" data-icon="&#xe602;"></span>
							<span class="screen-reader">Facebook</span>
						</a>
					</li>
					<li>
						<a href='https://plus.google.com/u/0/112484955141279120302/'>
							<span aria-hidden="true" data-icon="&#xe601;"></span>
							<span class="screen-reader">Google+</span>
						</a>
					</li>
					<li>
						<a href='https://twitter.com/jayrob_in'>
							<span aria-hidden="true" data-icon="&#xe603;"></span>
							<span class="screen-reader">Twitter</span>
						</a>
					</li>
					<li>
						<a href='http://www.github.com/jayrobin'>
							<span aria-hidden="true" data-icon="&#xe604;"></span>
							<span class="screen-reader">GitHub</span>
						</a>
					</li>
					<li>
						<a href='http://uk.linkedin.com/in/jayrobin'>
							<span aria-hidden="true" data-icon="&#xe605;"></span>
							<span class="screen-reader">LinkedIn</span>
						</a>
					</li>
					<li>
						<a href='mailto:james.michael.robinson@gmail.com'>
							<span aria-hidden="true" data-icon="&#xe600;"></span>
							<span class="screen-reader">Email</span>
						</a>
					</li>
				</ul>
			</nav>
		</footer>
	</body>
</html>