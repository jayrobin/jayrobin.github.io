<!DOCTYPE html>
<html>
	<head>
		<title>Jayrobin @ DBC</title>
		<meta charset='utf-8'>
		<link rel="shortcut icon" href="../images/favicon.ico">
		<link rel='stylesheet' href='../blog-posts/stylesheets/reset.css'>
		<link rel='stylesheet' href='../blog-posts/stylesheets/blog.css'>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-2202293-16', 'jayrobin.github.io');
      ga('send', 'pageview');

    </script>
	</head>
	<body ontouchstart>
		<header>
			<h1>JAYROBIN</h1>
			<nav>
				<ul>
					<li id='home'><a href='../index.html'>Home</a></li>
					<li id='about'><a href='../about.html'>About</a></li>
					<li id='github'><a href='http://www.github.com/jayrobin'>GitHub</a></li>
					<li id='contact'><a href='mailto:james.michael.robinson@gmail.com'>Contact</a></li>
				</ul>
			</nav>
			<h2>Or: how I learned to stop worrying and love programming</h2>
		</header>
		<main>
			<section>
				<article>
					<h3>Week Four - Technical blog</h3>
					<span class="article_content">
						<p>25 Jun 2014</p>
						<h4>Enumerating a collection</h4>
						<p>So you have a list of items in ruby and you want to enumerate (loop) over the collection, perhaps printing each one out to the terminal. If you're coming from Java, for example, you might think a 'for' loop might work...</p>
						<span class='code bad'>
							<span>for index in 0..list.length</span>
							<span>&nbsp;&nbsp;puts list[index]</span>
							<span>end</span>
						</span>
						<p>Technically it does, but this is a horrible, horrible approach in ruby. First of all, the loop is dependent on a number of variables that it shouldn't be: index, list.length, and 0 (the start index). While unlikely in a loop this simple, it introduces multiple points of failure that don't need to be there.</p>

						<p>So what about a 'for ... in ...' loop?</p>
						<span class='code bad'>
							<span>for item in list</span>
							<span>&nbsp;&nbsp;puts item</span>
							<span>end</span>
						</span>
						<p>Well, that <em>technically</em> works as well but once again is very un-'ruby-like' and also introduces a few problems. Specifically, for loops in ruby do not introduce new scope, so the 'item' variable will still be accessible (and contain the final element) after the loop is run. More importantly, if you have defined 'item' anywhere in the current scope prior to the above loop, it'll get overwritten.</p>

						<p>Perhaps a while loop?</p>
						<span class='code bad'>
							<span>index = 0</span>
							<span>while index < list.length</span>
							<span>&nbsp;&nbsp;puts list[index]</span>
							<span>&nbsp;&nbsp;index++</span>
							<span>end</span>
						</span>
						<p>Unlike 'for' loops, 'while' loops are not inherrently <em>bad</em>, but they are not best suited for enumeration. As with the initial 'for' loop, this loop introduces multiple points of failure that aren't necessary (the loop condition, setting the initial index, increasing the index).

						<p>So what's the best approach?</p>
						<span class='code good'>
							<span>item.each do |item|</span>
							<span>&nbsp;&nbsp;puts item</span>
							<span>end</span>
						</span>
						<p>Enumerators in ruby are clean, ruby-like, and very extensible blocks which are called for every element in a collection without the need to track the current index or worry about scope. Ruby offers a large number of enumerators for a variety of purposes, for example:</p>

						<ul>
							<li>each: simply enumerate over the entire collection</li>
							<li>map: apply a block to each element</li>
							<li>select: pull each element matching a condition into a separate collection</li>
							<li>reduce/inject: inject a variable into an enumeration to accumulate the result of the block</li>
						</ul>

						<h4>Looping a predetermined number of times</h4>
						<p>Sometimes you'll find yourself needing to loop a certain number of times, without particularly caring for the value of the index. In this situation, you may find yourself reaching for the 'for' loop again...</p>
						<span class='code bad'>
							<span>for index in 0..10</span>
							<span>&nbsp;&nbsp;do_something</span>
							<span>end</span>
						</span>
						<p>No! Send that 'for' loop back to the deepest darkest pit and pretend you've never heard of it!</p>

						<p>Maybe this is the right time to use a while loop?</p>
						<span class='code bad'>
							<span>index = 0</span>
							<span>while index < 10</span>
							<span>&nbsp;&nbsp;do_something</span>
							<span>&nbsp;&nbsp;index++</span>
							<span>end</span>
						</span>
						<p>Not quite yet - you're once again reliant on setting the correct starting index, checking the index against a <a href='http://en.wikipedia.org/wiki/Magic_number_(programming)#Unnamed_numerical_constants'>magic number</a>, and increasing it on every iteration. None of these should be necessary if you don't care about the value of the index.</p>

						<p>Thankfully, ruby integers offer a #times method which return an enumerator. We can therefore stick a block on the end to perform the block a given number of times.</p>
						<span class='code good'>
							<span>10.times do</span>
							<span>&nbsp;&nbsp;do_something</span>
							<span>end</span>
						</span>
						<p>If we wanted to do something with the index in the block, we can append a parameter after the 'do' to make it accessible, e.g. '10.times do |index|'.</p>

						<h4>Looping between two given indices</h4>
						<p>Let's say we <em>were</em> interested in the index, and the index was to be between two given values. Should be use a 'for' loop and a range?</p>
						<span class='code bad'>
							<span>for index in 10..20</span>
							<span>&nbsp;&nbsp;puts index</span>
							<span>end</span>
						</span>
						<p>I won't even dignify that with an answer.</p>

						<p>So how about a while loop?</p>
						<span class='code bad'>
							<span>index = 10</span>
							<span>while index < 20</span>
							<span>&nbsp;&nbsp;puts index</span>
							<span>&nbsp;&nbsp;index++</span>
							<span>end</span>
						</span>
						<p>For the same reasons as before, a while loop is not appropriate in this example</p>

						<p>Thankfully, there's another great integer method in ruby in the form of #upto...</p>
						<span class='code good'>
							<span>10.upto(20) do |index|</span>
							<span>&nbsp;&nbsp;puts index</span>
							<span>end</span>
						</span>
						<p>Similar to Integer#times, it will return an enumerator which we can apply a block to. The difference is that #upto (and #downto) take a parameter which is the final index of the loop.</p>

						<h4>Looping while a condition is true</h4>
						<p>Sometimes we'll want to keep running the same block of code until a particular condition is met. For example, moving a player character until the player dies. This is where the 'while' loop finally comes into play</p>
						<span class='code ok'>
							<span>while player.alive</span>
							<span>&nbsp;&nbsp;player.move</span>
							<span>end</span>
						</span>
						<p>So why is this code not ideal? Well it will work perfectly fine and not introduce any unexpected issues, but since we've only got one action occurring within the block we can shortcut it to something much cleaner:</p>
						<span class='code good'>
							<span>player.move while player.alive</span>
						</span>

						<h4>Looping until a condition is met</h4>
						<p>What if we want to keep looking until a given condition is false? For example, continuing a game until a game_over flag is true? Surely we should use a 'while' loop again?</p>
						<span class='code bad'>
							<span>take_turn while !game_over</span>
						</span>
						<p>As usual, this will work but it doesn't read particularly well: "take turn while not game over".</p>

						<p>Well ruby has one final shortcut we can use for this particular scenario:</p>
						<span class='code good'>
							<span>take_turn until game_over</span>
						</span>
						<p>The 'until' statement is essentially just an inverted 'while' loop, in that it will loop until a given condition is true, resulting in code that is much easier to read.</p>

						<p>So in summary...</p>
						<h4>FOR LOOPS ARE BAD</h4>
					</span>
				</article>
			</section>
		</main>
		<footer>
			<nav>
				<ul>
					<li>
						<a href='https://www.facebook.com/jamesmichaelrobinson'>
							<span aria-hidden="true" data-icon="&#xe602;"></span>
							<span class="screen-reader">Facebook</span>
						</a>
					</li>
					<li>
						<a href='https://plus.google.com/u/0/112484955141279120302/'>
							<span aria-hidden="true" data-icon="&#xe601;"></span>
							<span class="screen-reader">Google+</span>
						</a>
					</li>
					<li>
						<a href='https://twitter.com/jayrob_in'>
							<span aria-hidden="true" data-icon="&#xe603;"></span>
							<span class="screen-reader">Twitter</span>
						</a>
					</li>
					<li>
						<a href='http://www.github.com/jayrobin'>
							<span aria-hidden="true" data-icon="&#xe604;"></span>
							<span class="screen-reader">GitHub</span>
						</a>
					</li>
					<li>
						<a href='http://uk.linkedin.com/in/jayrobin'>
							<span aria-hidden="true" data-icon="&#xe605;"></span>
							<span class="screen-reader">LinkedIn</span>
						</a>
					</li>
					<li>
						<a href='mailto:james.michael.robinson@gmail.com'>
							<span aria-hidden="true" data-icon="&#xe600;"></span>
							<span class="screen-reader">Email</span>
						</a>
					</li>
				</ul>
			</nav>
		</footer>
	</body>
</html>